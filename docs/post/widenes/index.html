<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>wideNES - Peeking Past the Edge of NES Games :: prilik&#39;s blog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="" />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://prilik.com/blog/post/widenes/" />


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-58621690-1', 'auto');
	
	ga('send', 'pageview');
}
</script>



<link rel="stylesheet" href="https://prilik.com/blog/assets/style.css">

  <link rel="stylesheet" href="https://prilik.com/blog/assets/blue.css">






<link rel="apple-touch-icon" href="https://prilik.com/blog/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="https://prilik.com/blog/img/favicon/blue.png">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="wideNES - Peeking Past the Edge of NES Games">
<meta property="og:description" content="A explanation and exploration of wideNES, a novel technique to automatically and interactively map-out NES games in real time. Experience NES classics like never before... in widescreen!" />
<meta property="og:url" content="https://prilik.com/blog/post/widenes/" />
<meta property="og:site_name" content="prilik&#39;s blog" />

  
    <meta property="og:image" content="https://prilik.com/blog/img/favicon/blue.png">
  

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2018-08-24 00:00:00 -0400 EDT" />












</head>
<body class="blue">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/blog">
  <div class="logo">
    prilik&#39;s blog
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="https://github.com/daniel5151">github</a></li>
        
      
        
          <li><a href="/blog/">posts</a></li>
        
      
        
          <li><a href="https://prilik.com">whoami</a></li>
        
      
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="https://github.com/daniel5151">github</a></li>
      
    
      
        <li><a href="/blog/">posts</a></li>
      
    
      
        <li><a href="https://prilik.com">whoami</a></li>
      
    
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="https://prilik.com/blog/post/widenes/">wideNES - Peeking Past the Edge of NES Games</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2018-08-24 
      </span>
      <span> - 16 minute read</span>
    
    
  </div>

  
  <span class="post-tags">
    
    #<a href="https://prilik.com/blog/tags/emulation/">emulation</a>&nbsp;
    
    #<a href="https://prilik.com/blog/tags/nes/">nes</a>&nbsp;
    
    #<a href="https://prilik.com/blog/tags/c&#43;&#43;/">c&#43;&#43;</a>&nbsp;
    
  </span>
  

  

  
    <div class="table-of-contents">
      <h2>
        
          Table of Contents
        
      </h2>
      <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#how-widenes-works">How wideNES works</a>
          <ul>
            <li><a href="#pushing-pixels-with-the-ppu">Pushing Pixels with the PPU</a></li>
            <li><a href="#the-basic-idea">The Basic Idea</a></li>
            <li><a href="#tangent-why-not-extract-levels-directly-from-roms">Tangent: Why not extract levels directly from ROMs?</a></li>
            <li><a href="#scrolling-past-255">Scrolling past 255</a></li>
            <li><a href="#ignoring-static-screen-elements">Ignoring Static Screen Elements</a>
              <ul>
                <li><a href="#huds---non-issue">HUDs - Non-issue</a></li>
                <li><a href="#masks---easy-peasy">Masks - Easy Peasy</a></li>
                <li><a href="#status-bars---the-tricky-bit">Status Bars - The tricky bit</a></li>
              </ul>
            </li>
            <li><a href="#mid-frame-irq-tracking">Mid-Frame IRQ Tracking</a></li>
            <li><a href="#detecting-scenes">Detecting &ldquo;Scenes&rdquo;</a></li>
          </ul>
        </li>
        <li><a href="#whats-next-for-widenes">What&rsquo;s next for wideNES?</a>
          <ul>
            <li><a href="#improving-widenes-_core_">Improving wideNES <em>Core</em></a></li>
            <li><a href="#improving-aneses-widenes-implementation">Improving ANESE&rsquo;s wideNES implementation</a></li>
          </ul>
        </li>
        <li><a href="#conclusion">Conclusion</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
  

  <div class="post-content"><div>
        <p>In the mid 1980s, the Nintendo Entertainment System (NES) was <em>the</em> home console to have. Boasting the best sound, the best graphics, and the best games of any home-console to date, it pushed the envelope for what home-gaming could be. To this day, titles like <em>Super Mario Bros.</em>, <em>The Legend of Zelda</em>, and <em>Metroid</em> are hailed as some of the best games of all time.</p>
<p>Well, it&rsquo;s been over 30 years since the NES was released, and while those classic games have aged well, the same can&rsquo;t be said for the hardware they ran on. With a screen-resolution of just 256x240, the NES didn&rsquo;t give games all that much screen real-estate to work with. Nevertheless, intrepid game developers squeezed amazing, iconic worlds into NES games: the maze-like dungeons of <em>The Legend of Zelda</em>, the sprawling planet of <em>Metroid</em>, or the colorful levels of <em>Super Mario Bros.</em>. And yet, due to the NES&rsquo;s hardware limitations, gamers only ever experienced these worlds a single 256x240 viewport at a time&hellip;</p>
<p>Until now.</p>
<p>Introducing: <strong>wideNES</strong>.
A new way to experience NES classics.</p>
<p align="center">
  <img src="/blog/assets/wideNES/wideNES_metroid.gif"/>
</p>
<p align="center">
  <img align="center" src="/blog/assets/wideNES/wideNES_smb1.gif"/>
</p>
<p><strong>wideNES</strong> is a novel technique to <em>automatically</em> and <em>interactively</em> map-out NES games, <em>in real time</em>.</p>
<p>As players move within a level, wideNES records the screen, gradually building-up a map of what&rsquo;s been explored. On subsequent playthroughs of the level, wideNES syncs the action on-screen to the generated map, effectively letting players see more of the level by &ldquo;peeking&rdquo; past the edge of the NES&rsquo;s screen! Best of all, wideNES&rsquo;s approach to mapping games is <em>totally generalized</em>, enabling a wide range of NES games to work with wideNES right out of the box!</p>
<p>But how does it work?</p>
<hr>
<p>If you&rsquo;d like to try wideNES before reading up on how it works, go ahead and download <a href="https://prilik.com/ANESE">ANESE</a>. ANESE is a NES emulator I wrote myself, and at the time of writing, it&rsquo;s the only emulator that implements wideNES. Fair warning though, ANESE is <em>not</em> the best NES emulator out there, both in terms of UI and accuracy. Most options (including enabling wideNES) are only exposed via command line, and although many popular titles work just fine, some titles might not work as expected.</p>
<hr>
<h2 id="how-widenes-works">How wideNES works<a href="#how-widenes-works" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Before diving into the details, it&rsquo;s important to briefly discuss how the NES renders graphics.</p>
<h3 id="pushing-pixels-with-the-ppu">Pushing Pixels with the PPU<a href="#pushing-pixels-with-the-ppu" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Sitting at the heart of the NES is the venerable MOS 6502 CPU. In the late 70s and early 80s, the 6502 was <em>everywhere</em>, powering iconic machines like the Commodore 64, Apple II, and many more. It was cheap, easy to program, and <em>just</em> powerful enough to be dangerous.</p>
<p>Complimenting the NES&rsquo;s 6502 was a powerful graphics co-processor called the <em>Picture Processing Unit</em> (PPU). In comparison to basic video co-processors present in older 6502 based systems, the PPU was a huge step-up in usability. For example, half a decade prior to the NES&rsquo;s release, the Atari 2600 used a 6502 to issue graphics commands to it&rsquo;s co-processor <em>every-single scanline</em>, leaving little time for the CPU to execute game-logic. On the other hand, the PPU only requires a couple commands <em>per frame</em>, leaving plenty of time for the 6502 to deliver interesting and innovative gameplay.</p>
<p>The PPU is a fascinating chip, rendering graphics in a way unlike any modern GPU, and it would take a <a href="http://www.dustmop.io/blog/2015/04/28/nes-graphics-part-1/">whole series of articles</a> to fully explain how it works. Since wideNES only relies on a small subset of the PPU features to work, this brief overview of the PPU&rsquo;s features should suffice:</p>
<ul>
<li>Resolution: 256x240px @60Hz</li>
<li>Runs independently from the CPU
<ul>
<li>Communicates with CPU using <em>Memory Mapped I/O</em> (address range 0x2000 - 0x2007)</li>
</ul>
</li>
<li>2 rendering layers: The <strong>Sprite</strong> layer, and the <strong>Background</strong> layer
<ul>
<li><strong>Sprite Layer</strong>
<ul>
<li>Sprites can be individually positioned anywhere on-screen</li>
<li>Great for moving objects: player, enemies, projectiles</li>
<li>Up to 64 8x8px sprites</li>
</ul>
</li>
<li><strong>Background Layer</strong>
<ul>
<li>Locked to grid</li>
<li>Great for static elements: platforms, large obstacles, decoration</li>
<li>Enough VRAM to store 64x30 8x8px tiles
<ul>
<li>Effective <em>internal</em> resolution of 512x240, with a 256x240 viewport</li>
<li>Supports <strong><em>hardware scrolling</em></strong> to change the 256x240 viewport
<ul>
<li>PPUSCROLL register (address 0x2005) controls viewport X/Y offset</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>With that <em>incredibly</em> brief overview out of the way, lets move on to the interesting bit: how does wideNES work?</p>
<h3 id="the-basic-idea">The Basic Idea<a href="#the-basic-idea" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>At the end of each frame, the CPU updates the PPU on what has changed. This involves setting new sprite positions, new level data, and &mdash;crucially for wideNES&mdash; <em>new viewport offsets</em>. Since wideNES runs in an emulator, it&rsquo;s really easy to track the values written to the PPUSCROLL register, which means it&rsquo;s incredibly easy to calculate how much of the screen has scrolled between any two frames!</p>
<p>Hmm, what would happen if instead of painting each new frame <em>directly over</em> the old frame, new frames are instead painted <em>overlapping</em> the previous frame, but offset by the current screen scroll? Well, over time, more and more of the level would be left on-screen, gradually building up a complete picture of the level!</p>
<p>To test if the idea had any merit, I jumped right in and hacked together a first implementation.</p>
<p>Compile&hellip;
Run&hellip;
Load <em>Super Mario Bros.</em>&hellip;</p>
<p>Voila!</p>
<p align="center">
  <img align="center" src="/blog/assets/wideNES/smb1_v1.gif"/>
</p>
<p>It worked!</p>
<p>Kinda&hellip;</p>
<hr>
<h3 id="tangent-why-not-extract-levels-directly-from-roms">Tangent: Why not extract levels directly from ROMs?<a href="#tangent-why-not-extract-levels-directly-from-roms" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Without even going into the details of wideNES&rsquo;s implementation, it should be obvious that the technique has a major limitation: A complete map of the game is only possible if a player manually explores the entire game.</p>
<p>What if there was some way to extract levels from <em>raw</em> NES ROMs?!
Could such a technique even exist??</p>
<p>Nah, probably not.</p>
<p>If you take any 2 NES games, there is only 1 thing they are guaranteed to have in common: they both run on an NES. Other than that, all bets are off! This inconsistency is a real pain, since there are essentially limitless ways for NES games to store level data!</p>
<p>While some folks have extracted complete levels by reverse engineering how <em>a couple of</em> games store level data (sometimes making full-fledged <a href="https://www.romhacking.net/utilities/298/">level editors</a>!), doing so is far from simple, requiring plenty of hard work, dedication, and clever thinking.</p>
<p>Trying to extract level data from a NES ROM would be equivalent to determining which sections of the ROM are code (as opposed to data), which is hard, since <a href="https://stackoverflow.com/questions/5299576/finding-all-the-code-in-a-given-binary-is-equivalent-to-the-halting-problem-r">finding all code in a given binary is equivalent to the Halting problem</a>!</p>
<p>wideNES takes a much simpler approach: Instead of guessing how games pack level data in ROM, wideNES will simply run the game and watch the output!</p>
<hr>
<h3 id="scrolling-past-255">Scrolling past 255<a href="#scrolling-past-255" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>The NES is a 8-bit system, which means the PPUSCROLL register only accepts 8-bit values. This limits the maximum scroll-offset to just 255px, i.e: the largest 8-bit number. Not-so coincidentally, the NES&rsquo;s screen resolution is 240x256 pixels, so a 255px offset is <em>just-enough</em> to scroll the entire screen.</p>
<p>But what happens about scrolling <em>past</em> 255?</p>
<p>First, games will reset the PPUSCROLL register to 0. This explains why <em>SMB</em> would bounce-back to the start whenever Mario moved too-far right.</p>
<p>Next, to compensate for PPUSCROLL&rsquo;s 8-bit limitations, games will updates a different PPU register: PPUCTRL (address 0x2000). The bottom 2 bits of PPUCTRL define the &ldquo;origin&rdquo; of the current scene in full-frame increments. For example: writing a value of 1 shifts the viewport right by 256px, a value of 2 will shift the viewport down by 240px. This PPUCTRL offset <em>stacks</em> with the PPUSCROLL register, enabling the screen to scroll up to 512px left-to-right, or up to 480px top-to-bottom.</p>
<p>But hold on a sec, isn&rsquo;t there only enough VRAM for 2 screens-worth of level? What happens when the viewport scrolls too far to the right and &ldquo;overshoots&rdquo; VRAM? To handle this case, the PPU implements wrapping behavior, so that any sections of the viewport outside of designated VRAM will simply wrap-around to the opposite-end of VRAM.</p>
<p>This wrapping behavior, in conjunction with some clever PPUSCROLL and PPUCTRL manipulation, allows NES games to give the illusion of infinitely tall/wide worlds! By lazily-loading in more of the level ahead of the viewport, and gradually scrolling into it, players never realize that they are actually &ldquo;running in circles&rdquo; within VRAM!</p>
<p>This excellent illustration from the nesdev wiki shows how <em>Super Mario Bros.</em> uses these features to have levels longer than 2 screens:</p>
<p align="center">
  <img align="center" src="/blog/assets/wideNES/external/SMB1_scrolling_seam.gif"/>
</p>
<p>To get back to the question at hand: how does wideNES handle scrolling past 256?</p>
<p>Well, to be perfectly honest, wideNES <em>completely ignores</em> the PPUCTRL register, and simply looks that the PPUSCROLL delta between frames!</p>
<p>If PPUSCROLL unexpectedly jumps up to ~256, that typically indicates that the player character moved left/up a screen, whereas if it unexpectedly jumps down to ~0, that typically indicates that the player moved right/down a screen.</p>
<p>While this heuristic might seem simple &mdash;and it is&mdash; it actually works great!</p>
<p>After implementing the heuristic, <em>Super Mario Bros.</em>, <em>Metroid</em>, and many other games worked near-perfectly!</p>
<p>I was excited, so I went ahead and loaded up another NES classic, <em>Super Mario Bros. 3</em>&hellip;.</p>
<p align="center">
  <img align="center" src="/blog/assets/wideNES/smb3_v1.gif"/>
</p>
<p>Hmm&hellip; That&rsquo;s not good.</p>
<h3 id="ignoring-static-screen-elements">Ignoring Static Screen Elements<a href="#ignoring-static-screen-elements" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Many games have static-UI elements at the edges of the screen. In <em>SMB3</em>&rsquo;s case, there is a blue column on the left-side of the screen, and a status-bar at the bottom of the screen.</p>
<p>By default, wideNES samples in 16-pixel increments from the edges of the screen, which means any static elements at the edges are sampled! Not good!</p>
<p>To work around this issue, wideNES implements several rules and heuristics that try to detect and mask-off static screen elements automatically.</p>
<p>In general, there are 3 different types of static screen elements used in NES games: HUDs, Masks, and Status Bars.</p>
<h4 id="huds---non-issue">HUDs - Non-issue<a href="#huds---non-issue" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>If a game overlays it&rsquo;s HUD on-top of the level, chances are the HUD is comprised of several Sprites. Eg: the HUD in <em>Metroid</em>.</p>
<p>Thankfully, these HUDs are a non-issue, as wideNES simply ignores the sprite layer at the moment. Nice!</p>
<h4 id="masks---easy-peasy">Masks - Easy Peasy<a href="#masks---easy-peasy" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>The PPU has feature which allows games to mask-off the leftmost 8px of the background layer. It is activated by setting the 2nd bit of the PPUMASK register (address 0x2001). While many games use this feature, explaining <em>why</em> they do so is outside of the scope of this article.</p>
<p>Detecting if the mask is on is incredibly simple: wideNES simply watches the value of PPUMASK, and ignores the leftmost 8px whenever the 2nd bit of the register is set!</p>
<p>Implementing this simple rule seemed to fix <em>SMB3</em>:</p>
<p align="center">
  <img align="center" src="/blog/assets/wideNES/smb3_v2.gif"/>
</p>
<p>&hellip;well, <em>almost</em>.</p>
<h4 id="status-bars---the-tricky-bit">Status Bars - The tricky bit<a href="#status-bars---the-tricky-bit" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>Due to PPU limitations, there can only be 64 sprites on-screen at any give time, and furthermore, there can only be 8 sprites on a <em>particular scanline</em> at any given time. This limitation discourages games from building complex HUDs from sprites, and pushes games to use segments of the background layer to display information.</p>
<p>Aside from masks, the PPU doesn&rsquo;t really provide any easy way to divide the background layer between the play-area and the status-area. As such, games got creative, leading to a multitude of <em>unorthodox</em> ways to create status bars&hellip;</p>
<p>wideNES implements several different heuristics to detect different-types of status bars, but in the interest of time, I&rsquo;ll touch upon one of the more interesting heuristics: Mid-Frame IRQ tracking.</p>
<h3 id="mid-frame-irq-tracking">Mid-Frame IRQ Tracking<a href="#mid-frame-irq-tracking" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Unlike modern GPUs, which have large internal framebuffers, the PPU has <em>no frame-buffer whatsoever!</em> To save on space, the PPU stores scenes as a grid of 64x32 8x8 pixel tiles. Instead of resolving the pixel data ahead of time, tiles are stored as <em>pointers</em> into CHR Memory (Character Memory), which contains the actual pixel data.</p>
<p>Since the NES was developed in the 80s, the PPU was not built with modern display technology in mind. Instead of rendering full-frames at a time, the PPU outputs NTSC video designed to be displayed on a CRT, which outputs video <em>pixel by pixel</em>, <em>scanline by scanline</em>, top to bottom, left to right.</p>
<p>Why is all this important?</p>
<p>Well, since the PPU renders frames top-to-bottom, scanline-by-scanline, it is possible to send the PPU instructions <em>mid-frame</em> to create otherwise impossible video effects! These effects could be as simple as changing the palette, or as advanced as, you guessed it, creating Status Bars!</p>
<p>To explain how mid-frame PPU writes can generate Status Bars, I&rsquo;ve captured a raw dump of a slice of the PPU&rsquo;s VRAM and CHR Memory at a particular frame <em>SMB3</em>:</p>
<p align="center">
  <img align="center" src="/blog/assets/wideNES/raw_vram_level.png"/>
</p>
<p>Everything looks normal, nothing fancy&hellip; except look at the Status Bar! It&rsquo;s completely garbled!</p>
<p>Now, look at the same raw dump, but captured after scanline 196&hellip;</p>
<p align="center">
  <img align="center" src="/blog/assets/wideNES/raw_vram_status.png"/>
</p>
<p>Yes, the level looks terrible, but the status bar is completely intact!</p>
<p>What&rsquo;s going on??</p>
<p><em>SMB3</em> sets a timer to fire an IRQ precisely after rendering scanline 195. It puts the following instructions in the IRQ handler:</p>
<ul>
<li>Set PPUSCROLL to (0,0) (ensuring a fixed status bar)</li>
<li>Swap the tilemap in CHR Memory (un-garble the status-bar&rsquo;s graphics)</li>
</ul>
<p>Since the rest of the level has already been rendered, the PPU won&rsquo;t &ldquo;retroactively&rdquo; update the frame. Instead, it will keep-on rendering with these new parameters, outputting a nice, un-garbled status bar!</p>
<p>To get back to wideNES, by listening for any mid-frame IRQs and noting the scanline at which they occurred at, wideNES can ignore any subsequent scanlines in the recording! Alternatively, if the IRQ occurs at a scanline less than 240 / 2, all <em>previous</em> scanlines are ignored, as an early scanline IRQ implies there could be a status bar at the <em>top</em> of the screen.</p>
<p>Once this heuristic is in-place <em>Super Mario Bros. 3</em> works perfectly!</p>
<p align="center">
  <img align="center" src="/blog/assets/wideNES/smb3_v3.gif"/>
</p>
<hr>
<p>I briefly considered using a Computer Vision library such as OpenCV to detect status-bars (and other mostly-static regions of the screen), but I eventually decided against it. Using a huge, complex, and opaque Computer Vision library ran opposite to the ethos of wideNES, which tries to rely on small, simple, and transparent rules and heuristics to achieve results.</p>
<hr>
<h3 id="detecting-scenes">Detecting &ldquo;Scenes&rdquo;<a href="#detecting-scenes" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Aside from a few notable examples (such as <em>Metroid</em>), NES games tend <em>not</em> to take place within a single huge, uninterrupted level. Instead, most NES games are split into many smaller, separate &ldquo;scenes&rdquo; with doors or transition screens to move between them.</p>
<p>Since wideNES has no concept of &ldquo;scenes,&rdquo; bad things happen when scene changes occur&hellip;</p>
<p>For example, here is the first scene transition in <em>Castlevania</em>, where Simon Belmont enters Dracula&rsquo;s castle:</p>
<p align="center">
  <img align="center" src="/blog/assets/wideNES/castlevania_no_scene.gif"/>
</p>
<p>Oh, that&rsquo;s not good! wideNES completely overwrote the last bit of the level with the first bit of the new level!</p>
<p>Clearly, wideNES needed some way to detect when a scene changes. But how?</p>
<p><em>Perceptual Hashing!</em></p>
<p>Unlike <em>cryptographic</em> hash functions, which seek to scatter similar inputs randomly across the output space, <em>perceptual</em> hash functions strive to keep similar inputs &ldquo;close&rdquo; to one another in the output space. This makes perceptual hashes perfect for detecting similar images!</p>
<p>Perceptual hash functions can get incredibly complex, with some being able to detect similar images even if one has been rotated, scaled, stretched, and color shifted. Fortunately, wideNES doesn&rsquo;t need a complex hash function, since each frame is guaranteed to be the exact same size. As such, wideNES makes use of probably the simplest perceptual hash out there: <em>summing up every pixel on-screen!</em></p>
<p>It&rsquo;s simple, but it works pretty well!</p>
<p>For example, look how much the scene transitions stand-out when plotting the perceptual hash over time in <em>The Legend of Zelda</em>:</p>
<p align="center">
  <img align="center" src="/blog/assets/wideNES/perceptual_hash_zelda.png"/>
</p>
<p>At the moment, wideNES uses a fixed-threshold between perceptual hash values to trigger a scene transition, but this is far from ideal. Different games can use different palettes, and there are many cases when wideNES thinks there is a scene transition when there isn&rsquo;t. Ideally, wideNES should use a a dynamic-threshold, but at the moment, a fixed-threshold will do.</p>
<p>With this new heuristic in place, wideNES effectively detects Simon entering the castle in <em>Castlevania</em> and switches to a fresh-canvas appropriately.</p>
<p align="center">
  <img align="center" src="/blog/assets/wideNES/castlevania_with_scene.gif"/>
</p>
<p>And with that, the final big puzzle-piece of wideNES slid into place.</p>
<p>After implementing some basic serialization, I was finally able to boot-up a NES game, play though some levels, and automatically generate maps of the levels!</p>
<h2 id="whats-next-for-widenes">What&rsquo;s next for wideNES?<a href="#whats-next-for-widenes" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>wideNES is composed of two distinct parts: wideNES <em>Core</em>, which is the actual rules/heuristics behind the technique, and the concrete implementation of wideNES within ANESE.</p>
<h3 id="improving-widenes-_core_">Improving wideNES <em>Core</em><a href="#improving-widenes-_core_" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>First of all, wideNES tends to detect scene transitions too aggressively. The number of false-positives could be minimized by using a better perceptual-hashing algorithm, or by switching to a dynamic-threshold between perceptual-hashes.</p>
<p>Detecting static screen elements also needs more work. For example, <em>Megaman IV</em> has a mid-frame IRQ, but no status bar, leading wideNES to mistakenly ignore a sizable chunk of the playfield. While that particular case can be fixed with some manual adjustment, it would be better to have smarter heuristics instead.</p>
<p>Several NES games scroll the screen in &ldquo;unique&rdquo; ways. One high-profile example of this is <em>The Legend of Zelda</em>, which uses PPUSCROLL to scroll horizontally, yet scrolls vertically using a totally different register, PPUADDR. <em>Zelda</em> is a pretty popular title, so wideNES implements a heuristic just for <em>Zelda</em>. There are other games with similar &ldquo;unique&rdquo; scroll modes which would also require custom heuristics.</p>
<p>It would be useful to have some way to &ldquo;stitch-together&rdquo; identical scenes. For example, if one plays through <em>Super Mario Bros.</em> Level 1, but takes the pipe to the underground coin-stash, wideNES will create two separate scenes for Level 1: Scene A, the level up-to the point where Mario enters the coin-zone, and Scene B, the level from when Mario exits the pipe to the flagpole. If the game is then reloaded and Level 1 is replayed <em>without</em> entering the pipe, wideNES will just simply update Scene A to have the full full-level, but leave Scene B &ldquo;dangling.&rdquo;</p>
<p>Lastly, wideNES should keep-track of scene-transitions. With that data, it would be possible to build a graph of scene transitions, making it possible to generate world-maps for games that are <em>not</em> composed of a single, large world.</p>
<h3 id="improving-aneses-widenes-implementation">Improving ANESE&rsquo;s wideNES implementation<a href="#improving-aneses-widenes-implementation" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>At the moment, wideNES&rsquo;s only implementation is within ANESE, a NES emulator I wrote myself. ANESE is a very, <em>very</em> spartan emulator, with most options hidden behind CLI flags, and with the only UI implemented being a basic file-picker overlay! It is far, <em>far</em> from &ldquo;production ready.&rdquo;</p>
<p>Aside from the UI though, ANESE and wideNES could both use some compatibility and performance improvements. ANESE was the first large emulator I&rsquo;ve written, and it shows!</p>
<p>There are quite a few compatibility issues, with several games playing incorrectly / not booting at all. Fortunately, just because ANESE isn&rsquo;t a great emulator, does not mean that wideNES is a bad technique. The principles wideNES relies on are solid, and should be easy to implement in other emulators!</p>
<p>Performance wise, ANESE and wideNES are not the greatest, and even some relatively powerful PCs can sometimes dip below 60fps! There are many optimizations that should be implemented in ANESE and wideNES. Aside from general improvements in ANESE core, there are lots of improvements to how wideNES records frames, renders the map, and samples hashes.</p>
<h2 id="conclusion">Conclusion<a href="#conclusion" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>While I&rsquo;ve discussed the major aspects of how wideNES works, there many smaller techniques that I wasn&rsquo;t able to cover. For example, wideNES keeps a map of each frame&rsquo;s true-hash and it&rsquo;s scroll values, which are used to allow &ldquo;reentrant&rdquo; scenes. This feature, and many more, are described in the heavily-commented source for wideNES, available on the <a href="https://prilik.com/ANESE/wideNES">wideNES project page</a>.</p>
<p>Working on wideNES has been a truly awesome experience, but with another semester at the University of Waterloo right around the corner, I doubt I&rsquo;ll get the chance to work on wideNES for a while. wideNES is at a point where it mostly works, and i&rsquo;m glad I could write this post discussing some of the tech behind it!</p>
<p>Try wideNES yourself, and tell me what you think! Download <a href="https://prilik.com/ANESE">ANESE</a>, boot up some <em>Super Mario Bros.</em>, or <em>The Legend of Zelda</em>, or <em>Metroid</em>, and have some fun!</p>
      </div></div>

  
  
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        <span class="button previous">
            <a href="https://prilik.com/blog/post/crosvm-paravirt/">
                <span class="button__icon">←</span>
                <span class="button__text">Paravirtualized Devices in crosvm - a Performance Panacea for Modern VMs</span>
            </a>
        </span>
        
        
    </div>
</div>

  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">
        <span>Copyright &copy; Daniel Prilik :: Licensed under <a target="_blank" rel="external noopener license" href="https://creativecommons.org/licenses/by-nd/4.0/">CC-BY-ND-4.0</a>.</span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="https://prilik.com/blog/assets/main.js"></script>







  
</div>

</body>
</html>
